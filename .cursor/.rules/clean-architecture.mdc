---
alwaysApply: true
---
# Clean Architecture - Fundamental Principles

## Definition

Clean Architecture organizes code in concentric layers where:
- **Inner layers do NOT depend on outer layers**
- **The outermost layer depends on all inner layers**

## Project Layers (from inner to outer)

1. **Domain** (innermost) - Pure business logic
2. **Application** - Use cases and orchestration
3. **Infrastructure** - Technical implementations (DB, external services)
4. **Interfaces** (outermost) - Adapters (HTTP, CLI, etc.)

## Dependency Rule

```
interfaces → infrastructure → application → domain
interfaces → application → domain
infrastructure → domain
```

**Translated**:
- `interfaces/` can import from all layers
- `infrastructure/` can import from `domain/` and `application/`
- `application/` can import from `domain/`
- `domain/` CANNOT import from ANY other layer

## Rules by Layer

### Domain Layer

**What does it contain?**
- Entities with business logic
- Value Objects
- Repository and service interfaces
- Pure business rules

**What does it NOT contain?**
- Frameworks (NestJS, Express, etc.)
- Database libraries (Drizzle ORM, TypeORM, etc.)
- External services (Email, SMS, etc.)
- Infrastructure dependencies

**Correct example**:
```typescript
// domain/entities/appointment.entity.ts
export class Appointment {
  constructor(
    private readonly id: string,
    private readonly clientId: string,
    private readonly professionalId: string,
    private readonly dateTime: DateTime
  ) {}

  // Pure business logic
  isInThePast(): boolean {
    return this.dateTime.isBefore(DateTime.now());
  }
}
```

### Application Layer

**What does it contain?**
- Use cases
- Business logic orchestration
- Internal DTOs

**What does it NOT contain?**
- Repository implementations
- Direct calls to external services
- HTTP logic

**Correct example**:
```typescript
// application/use-cases/create-appointment.usecase.ts
export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: AppointmentRepository, // interface
    private readonly availabilityRepository: AvailabilityRepository // interface
  ) {}

  async execute(data: CreateAppointmentDto): Promise<Appointment> {
    // Orchestration using interfaces, not implementations
  }
}
```

### Infrastructure Layer

**What does it contain?**
- Repository implementations (Drizzle ORM, etc.)
- External services (Email, SMS, Google Calendar)
- Technical configurations

**Can use**:
- ORMs, database libraries
- External APIs
- Technical frameworks

**Correct example**:
```typescript
// infrastructure/database/repositories/drizzle-appointment.repository.ts
export class DrizzleAppointmentRepository implements AppointmentRepository {
  constructor(private readonly db: ReturnType<typeof drizzle>) {}

  async save(appointment: Appointment): Promise<void> {
    // Implementation with Drizzle
  }
}
```

### Interfaces Layer

**What does it contain?**
- HTTP controllers (NestJS)
- Authentication guards
- DTO ↔ Domain mappers
- Provider configuration (DI)

**Responsibility**:
- Receive HTTP requests
- Call use cases
- Transform DTOs to domain entities
- Map responses

**Correct example**:
```typescript
// interfaces/http/controllers/appointment.controller.ts
@Controller('appointments')
export class AppointmentController {
  constructor(
    private readonly createAppointmentUseCase: CreateAppointmentUseCase
  ) {}

  @Post()
  async create(@Body() dto: CreateAppointmentDto) {
    // Thin controller: only calls use case
    return this.createAppointmentUseCase.execute(dto);
  }
}
```

## Key Principles

### 1. Framework Independence
- Domain must be independent of NestJS
- Can change framework without touching domain

### 2. UI Independence
- Business logic does not know HTTP
- Can expose via CLI, GraphQL, etc. without changes

### 3. Database Independence
- Domain does not know Drizzle ORM or SQL
- Can change DB without touching domain

### 4. Testability
- Each layer must be independently testable
- Domain must be testable without complex mocks

## Violation Signs

If you find these patterns, there is a violation:

1. **NestJS import in domain/**:
   ```typescript
   // ❌ BAD
   import { Injectable } from '@nestjs/common';
   ```

2. **Drizzle import in domain/**:
   ```typescript
   // ❌ BAD
   // domain/entities/user.entity.ts
   import { drizzle } from 'drizzle-orm/node-postgres';
   ```

3. **HTTP logic in application/**:
   ```typescript
   // ❌ BAD
   import { Request, Response } from 'express';
   ```

4. **Business logic in controllers**:
   ```typescript
   // ❌ BAD
   @Controller()
   export class UserController {
     async create(@Body() dto) {
       // Business validation here
       // Password hash here
       // Complex logic here
     }
   }
   ```

## Continuous Validation

Review on each commit:
- ✅ Is domain free of frameworks?
- ✅ Do use cases orchestrate without depending on infrastructure?
- ✅ Are controllers thin?
- ✅ Do dependencies follow the correct flow?
