# KISS Principle (Keep It Simple, Stupid)

## Fundamental Rule

**Always prefer simple solutions over unnecessarily complex architectures.**

## Application in MVP

### MVP = Essential Functionality

This is an MVP (Minimum Viable Product). Therefore:
- ✅ Implement ONLY what is necessary to make it work
- ❌ DO NOT implement features "just in case"
- ❌ DO NOT create unnecessary abstractions
- ❌ DO NOT over-engineer

### Simplicity First

If something can be done simply, **do it simply**.

**Correct example**:
```typescript
// ✅ GOOD: Simple and direct for MVP
export class CreateAppointmentUseCase {
  async execute(data: CreateAppointmentDto): Promise<Appointment> {
    // Validate availability
    // Create appointment
    // Send notifications
    return appointment;
  }
}
```

**Incorrect example**:
```typescript
// ❌ BAD: Unnecessary over-engineering for MVP
export class CreateAppointmentUseCase {
  // Builder pattern, factory pattern, decorators, etc.
  // when a simple class works well
}
```

## Avoid Over-Engineering

### ❌ DO NOT Create Abstractions "Just In Case"

**Incorrect**:
```typescript
// ❌ BAD: Create abstractions that are not needed yet
interface IRepository<T> {
  // Generic interface that is not used anywhere
}
```

**Correct**:
```typescript
// ✅ GOOD: Create interfaces when they are really needed
interface UserRepository {
  // Specific interface that is used
}
```

### ❌ DO NOT Implement Complex Patterns Without Need

If a simple solution works, do not add:
- Multiple inheritance
- Complex decorators
- Advanced design patterns without justification
- Unnecessary additional frameworks

### ✅ Implement Only What Is Necessary

**Rule**: If `proyect_requirements.md` does not explicitly mention it, it's probably not necessary for the MVP.

### ✅ Refactor When Really Needed

- First, make it work (simple)
- Then, if really needed, refactor
- Do not optimize prematurely

## Scope Verification

**BEFORE** adding any feature, consult:

1. `proyect_requirements.md` - Is it in the functional requirements?
2. `proyect_requirements.md` section "MVP Scope (Explicitly Out)" - Is it excluded?
3. `technical_checklist.md` - Is it part of the current phase?

### Features Explicitly Out of Scope

According to `proyect_requirements.md`, DO NOT implement:
- ❌ Payments
- ❌ Appointment cancellation or rescheduling
- ❌ Automatic prior reminders
- ❌ Chats between users
- ❌ Admin panel
- ❌ Advanced calendar handling (holidays, exceptions, buffers)
- ❌ Multi-currency or internationalization

## Over-Engineering Signs

If you find these patterns, there is probably over-engineering:

1. **Unused abstractions**: Interfaces or classes created "just in case"
2. **Complex patterns without justification**: Using advanced design patterns without real need
3. **Unnecessary multiple layers**: Adding layers that don't add value
4. **Complex configurations**: Excessive setup for simple functionality
5. **Features outside MVP**: Implementing things not required

## Balance: KISS vs Clean Architecture

**KISS does not mean disorganized code**.

- ✅ Maintain Clean Architecture (simplicity in structure)
- ✅ Maintain SOLID (simplicity in design)
- ❌ Does NOT mean mixing layers for "simplicity"
- ❌ Does NOT mean avoiding necessary patterns (like Strategy for notifications)

**Rule**: Use the SIMPLEST solution that respects Clean Architecture and SOLID.

## Practical Examples

### Simple Validation

**✅ GOOD (KISS)**:
```typescript
// Simple and direct validation
if (!email || !email.includes('@')) {
  throw new Error('Invalid email');
}
```

**❌ BAD (Over-engineering)**:
```typescript
// Unnecessary complex validation for MVP
class EmailValidatorFactory {
  createValidator(config) {
    return new CompositeValidator([
      new RegexValidator(),
      new DomainValidator(),
      new MXRecordValidator(),
      // ... for a simple MVP
    ]);
  }
}
```

### Simple Persistence

**✅ GOOD (KISS)**:
```typescript
// Drizzle directly in the repository
export class DrizzleUserRepository {
  async save(user: User): Promise<void> {
    await this.db.insert(users).values(user);
  }
}
```

**❌ BAD (Over-engineering)**:
```typescript
// Unnecessary multiple layers
class UserRepositoryDecorator {
  constructor(private repository: IRepository<User>) {}
  // ... unnecessary wrappers
}
```

## KISS Checklist

Before implementing:
- ✅ Is it the simplest solution that works?
- ✅ Is it within MVP scope?
- ✅ Am I not adding unnecessary complexity?
- ✅ Do I really need this abstraction now?
- ✅ Is this in the requirements or is it "nice to have"?
