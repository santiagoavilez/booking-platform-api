---
alwaysApply: false
---

# Anti-Patterns to Avoid

## Definition

Anti-patterns are common solutions to recurring problems that seem correct but are counterproductive. This document lists the most common anti-patterns to avoid in this project.

## 1. God Object

### ❌ What it is

A class that does too many things and has too many responsibilities.

### ❌ Incorrect Example

```typescript
// ❌ BAD: A class that does EVERYTHING
export class UserService {
  async createUser() { }
  async updateUser() { }
  async deleteUser() { }
  async sendEmail() { }
  async validatePassword() { }
  async generateToken() { }
  async saveToDatabase() { }
  // ... 50 more methods
}
```

### ✅ Solution

Separate responsibilities into specific classes:
- `CreateUserUseCase` - Create user
- `EmailService` - Send emails
- `PasswordHasher` - Password hashing
- `UserRepository` - Persistence

## 2. Anemic Domain Model

### ❌ What it is

Entities that only contain data (getters/setters) without business logic.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Entity without business logic
export class Appointment {
  id: string;
  clientId: string;
  professionalId: string;
  dateTime: Date;
  
  // Only getters/setters, no logic
  getId() { return this.id; }
  getClientId() { return this.clientId; }
}
```

### ✅ Solution

Move business logic to entities:

```typescript
// ✅ GOOD: Entity with domain logic
export class Appointment {
  constructor(
    private readonly id: string,
    private readonly clientId: string,
    private readonly professionalId: string,
    private readonly dateTime: DateTime
  ) {}

  // Business logic in the entity
  isInThePast(): boolean {
    return this.dateTime.isBefore(DateTime.now());
  }

  canBeCancelled(): boolean {
    const hoursUntilAppointment = this.dateTime.diff(DateTime.now()).hours;
    return hoursUntilAppointment > 24;
  }
}
```

## 3. Feature Envy

### ❌ What it is

A method that uses more data or methods from another class than from its own.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Method that accesses another class too much
export class AppointmentController {
  async create(dto: CreateAppointmentDto) {
    // Accesses Appointment too much instead of using its methods
    if (dto.dateTime < new Date()) {
      throw new Error('Past date');
    }
    if (dto.professionalId === dto.clientId) {
      throw new Error('Same user');
    }
    // ... much logic that should be in Appointment
  }
}
```

### ✅ Solution

Move logic to where it belongs:

```typescript
// ✅ GOOD: Logic in the entity
export class Appointment {
  static create(data: CreateAppointmentData): Appointment {
    // Validations here
    if (data.dateTime.isInThePast()) {
      throw new Error('Appointment cannot be in the past');
    }
    if (data.professionalId === data.clientId) {
      throw new Error('Professional and client cannot be the same');
    }
    return new Appointment(/* ... */);
  }
}
```

## 4. Circular Dependencies

### ❌ What it is

Two or more modules/classes that import each other.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Circular dependency
// file-a.ts
import { B } from './file-b';
export class A {
  useB() { new B().method(); }
}

// file-b.ts
import { A } from './file-a'; // ❌ Circular
export class B {
  useA() { new A().method(); }
}
```

### ✅ Solution

1. Extract common dependency to a third module
2. Use dependency injection
3. Refactor to eliminate mutual dependency

```typescript
// ✅ GOOD: No circularity
// common.ts
export interface CommonInterface { }

// file-a.ts
import { CommonInterface } from './common';
export class A implements CommonInterface { }

// file-b.ts
import { CommonInterface } from './common';
export class B {
  use(common: CommonInterface) { }
}
```

## 5. Leaky Abstractions

### ❌ What it is

An abstraction that exposes implementation details that should be hidden.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Interface that exposes Drizzle details
export interface UserRepository {
  // Exposes that Drizzle is used
  findMany(args: any): Promise<User[]>;
  
  // Exposes database structure
  findByEmailIncludeProfile(email: string): Promise<UserWithProfile>;
}
```

### ✅ Solution

Abstraction that hides implementation:

```typescript
// ✅ GOOD: Implementation-independent interface
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: Email): Promise<User | null>;
  save(user: User): Promise<void>;
  // Does not expose Drizzle or SQL details
}
```

## 6. Premature Optimization

### ❌ What it is

Optimizing code before measuring and confirming there is a performance problem.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Complex optimization without need
export class UserRepository {
  // Complex cache, memoization, etc. without measuring first
  private cache = new Map();
  private memoizedQueries = new WeakMap();
  // ... unnecessary complexity for MVP
}
```

### ✅ Solution

First make it work, then measure and optimize if necessary:

```typescript
// ✅ GOOD: Simple first
export class DrizzleUserRepository {
  async findById(id: string): Promise<User | null> {
    // Simple implementation
    return this.db.select().from(users).where(eq(users.id, id)).limit(1);
  }
}
// Optimize only if really needed after measuring
```

## 7. Gold Plating (Over-Design)

### ❌ What it is

Adding features or functionality that are not in the requirements, "just in case".

### ❌ Incorrect Example

Adding to MVP:
- Payment system (not required)
- Admin panel (explicitly out of scope)
- Chat between users (not required)
- Appointment cancellation (outside MVP)

### ✅ Solution

Strictly follow `proyect_requirements.md` and `technical_checklist.md`:
- ✅ Implement only what is required
- ✅ Check scope before adding features
- ✅ Focus on MVP

## 8. Magic Numbers/Strings

### ❌ What it is

Using literal values without explanation or constants.

### ❌ Incorrect Example

```typescript
// ❌ BAD: Magic numbers
if (hoursUntilAppointment < 24) {
  throw new Error('Cannot cancel');
}

// Magic strings
if (user.role === 'profesional') { // Possible typo, no validation
  // ...
}
```

### ✅ Solution

Use constants with descriptive names:

```typescript
// ✅ GOOD: Constants
const MIN_HOURS_FOR_CANCELLATION = 24;

if (hoursUntilAppointment < MIN_HOURS_FOR_CANCELLATION) {
  throw new Error('Cannot cancel');
}

// Value Objects or Enums
enum Role {
  CLIENT = 'CLIENT',
  PROFESSIONAL = 'PROFESSIONAL',
}

if (user.role === Role.PROFESSIONAL) {
  // ...
}
```

## 9. Long Parameter List

### ❌ What it is

Methods or constructors with too many parameters (more than 3-4).

### ❌ Incorrect Example

```typescript
// ❌ BAD: Too many parameters
createAppointment(
  clientId: string,
  professionalId: string,
  date: Date,
  time: string,
  duration: number,
  notes: string,
  reminder: boolean,
  // ... more parameters
) { }
```

### ✅ Solution

Use objects/DTOs:

```typescript
// ✅ GOOD: Object with parameters
createAppointment(data: CreateAppointmentDto) {
  // data contains all parameters organized
}
```

## 10. Shotgun Surgery

### ❌ What it is

Changing a feature requires modifying multiple files in different places.

### ❌ Incorrect Example

To change how email is validated, you have to modify:
- Controller
- Use Case
- Entity
- Repository
- Tests in 5 different places

### ✅ Solution

Centralize logic in a single place (Value Object, for example):

```typescript
// ✅ GOOD: Centralized validation
export class Email {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new Error('Invalid email');
    }
  }
  // Validation in a single place
}
```

## Anti-Patterns Checklist

Before commit, verify:
- ✅ No "God Objects"?
- ✅ Do entities have business logic?
- ✅ No circular dependencies?
- ✅ Do abstractions not leak implementation?
- ✅ No premature optimization?
- ✅ Only MVP features?
- ✅ No magic numbers/strings?
- ✅ Methods don't have too many parameters?
