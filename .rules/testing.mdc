---
alwaysApply: false
---

# Testing Rules

## Test Structure

### Unit Tests

**For what**: Pure business logic, use cases, entities, value objects.

**Location**: Next to the code file
- `*.spec.ts` next to the original file
- Example: `create-appointment.usecase.ts` → `create-appointment.usecase.spec.ts`

**Example**:
```typescript
// application/use-cases/create-appointment.usecase.spec.ts
import { CreateAppointmentUseCase } from './create-appointment.usecase';

describe('CreateAppointmentUseCase', () => {
  it('should create an appointment', () => {
    // Unit test
  });
});
```

### Integration Tests

**For what**: Repositories, database integrations, external services.

**Location**: Next to the file or in `__tests__/` folder

**Example**:
```typescript
// infrastructure/database/repositories/__tests__/drizzle-appointment.repository.spec.ts
import { DrizzleAppointmentRepository } from '../drizzle-appointment.repository';

describe('DrizzleAppointmentRepository', () => {
  it('should save appointment to database', async () => {
    // Integration test with real DB or mock
  });
});
```

### E2E Tests (End-to-End)

**For what**: Complete HTTP endpoints, complete user flows.

**Location**: `test/` in project root

**Example**:
```typescript
// test/appointment.e2e-spec.ts
import request from 'supertest';

describe('Appointment E2E', () => {
  it('POST /appointments should create appointment', () => {
    // Complete E2E test
  });
});
```

## Naming Conventions

### Test Files
- **Format**: `*.spec.ts` for unit and integration tests
- **Format**: `*.e2e-spec.ts` for E2E tests
- **Location**: Next to code or in `test/` for E2E

### Describe Blocks
```typescript
describe('ClassName', () => {
  describe('methodName', () => {
    it('should do something specific', () => {
      // test
    });
  });
});
```

### Test Names
- Use clear descriptions that explain what the code should do
- Format: `should [expected action]`
- Examples:
  - `should create appointment when available`
  - `should throw error when appointment is in the past`
  - `should send notification to both client and professional`

## Mocking in Tests

### Repository Mocking

**✅ GOOD**:
```typescript
const mockUserRepository: jest.Mocked<UserRepository> = {
  findById: jest.fn(),
  save: jest.fn(),
};

// In the test
mockUserRepository.findById.mockResolvedValue(user);
```

### External Service Mocking

**✅ GOOD**:
```typescript
const mockNotificationStrategy: jest.Mocked<NotificationStrategy> = {
  send: jest.fn(),
};
```

### Avoid Domain Mocking

**❌ BAD**: Mock domain entities or value objects
**✅ GOOD**: Use real instances of entities in tests

## Coverage

### Minimum Recommended Coverage

- **Domain**: 100% (critical logic)
- **Application (Use Cases)**: >90%
- **Infrastructure**: >80%
- **Interfaces (Controllers)**: >70%

### Run Coverage

```bash
npm run test:cov
```

## AAA Structure (Arrange-Act-Assert)

**✅ GOOD**:
```typescript
it('should create appointment when available', async () => {
  // Arrange: Prepare data and mocks
  const appointmentData = {
    professionalId: 'prof-1',
    clientId: 'client-1',
    dateTime: new DateTime('2026-01-20T10:00:00Z'),
  };
  const mockRepository = createMockRepository();

  // Act: Execute the action
  const result = await useCase.execute(appointmentData);

  // Assert: Verify result
  expect(result).toBeDefined();
  expect(mockRepository.save).toHaveBeenCalledWith(expect.any(Appointment));
});
```

## Testing the Domain

### Entities

**✅ GOOD**: Test business logic of entities

```typescript
// domain/entities/appointment.entity.spec.ts
describe('Appointment', () => {
  it('should throw error when date is in the past', () => {
    const pastDate = DateTime.now().subtract({ days: 1 });
    
    expect(() => {
      new Appointment('id', 'client', 'prof', pastDate);
    }).toThrow('Appointment cannot be in the past');
  });
});
```

### Value Objects

**✅ GOOD**: Test value object validation

```typescript
// domain/value-objects/email.vo.spec.ts
describe('Email', () => {
  it('should throw error for invalid email format', () => {
    expect(() => {
      new Email('invalid-email');
    }).toThrow('Invalid email format');
  });
});
```

## Testing Use Cases

### Mock Dependencies

**✅ GOOD**:
```typescript
// application/use-cases/create-appointment.usecase.spec.ts
describe('CreateAppointmentUseCase', () => {
  let useCase: CreateAppointmentUseCase;
  let mockAppointmentRepository: jest.Mocked<AppointmentRepository>;
  let mockAvailabilityRepository: jest.Mocked<AvailabilityRepository>;

  beforeEach(() => {
    mockAppointmentRepository = {
      save: jest.fn(),
    };
    mockAvailabilityRepository = {
      isAvailable: jest.fn(),
    };
    
    useCase = new CreateAppointmentUseCase(
      mockAppointmentRepository,
      mockAvailabilityRepository
    );
  });

  it('should create appointment when available', async () => {
    // Arrange
    mockAvailabilityRepository.isAvailable.mockResolvedValue(true);
    
    // Act
    const result = await useCase.execute(validData);
    
    // Assert
    expect(mockAppointmentRepository.save).toHaveBeenCalled();
  });
});
```

## Testing Repositories (Integration)

### Use Test Database

**✅ GOOD**: Use Drizzle ORM with separate test database

```typescript
// infrastructure/database/repositories/__tests__/drizzle-user.repository.spec.ts
describe('DrizzleUserRepository (Integration)', () => {
  let repository: DrizzleUserRepository;
  let db: ReturnType<typeof drizzle>;

  beforeAll(async () => {
    db = drizzle({
      // Test DB connection
    });
    repository = new DrizzleUserRepository(db);
  });

  afterAll(async () => {
    // Close connection if necessary
  });

  it('should save and retrieve user', async () => {
    // Test with real test DB
  });
});
```

## Testing Controllers (E2E or Unit)

### E2E with Supertest

**✅ GOOD**:
```typescript
// test/appointment.e2e-spec.ts
describe('AppointmentController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      // Configure test module
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/appointments (POST)', () => {
    return request(app.getHttpServer())
      .post('/appointments')
      .send(validAppointmentData)
      .expect(201);
  });
});
```

## Testing Principles

### 1. Independent Tests

Each test must be able to run independently without depending on other tests.

### 2. Deterministic Tests

Tests must give the same result always (no randomness, no unstable external dependencies).

### 3. Fast Tests

Unit tests must be fast (<100ms each). Integration tests can be slower.

### 4. Clear Tests

The test name must clearly explain what is being tested and what result is expected.

### 5. One Assert per Concept

Prefer multiple related `expect()` that verify the same concept, but avoid tests that validate too many different things.

## Testing Checklist

Before commit:
- ✅ Do I have tests for the new logic?
- ✅ Are test names descriptive?
- ✅ Do tests follow the AAA structure?
- ✅ Am I mocking dependencies correctly?
- ✅ Are tests independent?
- ✅ Is test code clear and maintainable?
