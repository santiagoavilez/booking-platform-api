# Principio KISS (Keep It Simple, Stupid)

## Regla Fundamental

**Preferir siempre soluciones simples sobre arquitecturas complejas innecesarias.**

## Aplicación en el MVP

### MVP = Funcionalidad Esencial

Este es un MVP (Minimum Viable Product). Por lo tanto:
- ✅ Implementar SOLO lo necesario para que funcione
- ❌ NO implementar features "por si acaso"
- ❌ NO crear abstracciones innecesarias
- ❌ NO over-engineer

### Simplicidad Primero

Si algo se puede hacer de forma simple, **hazlo simple**.

**Ejemplo correcto**:
```typescript
// ✅ BIEN: Simple y directo para MVP
export class CreateAppointmentUseCase {
  async execute(data: CreateAppointmentDto): Promise<Appointment> {
    // Validar disponibilidad
    // Crear appointment
    // Enviar notificaciones
    return appointment;
  }
}
```

**Ejemplo incorrecto**:
```typescript
// ❌ MAL: Over-engineering innecesario para MVP
export class CreateAppointmentUseCase {
  // Builder pattern, factory pattern, decorators, etc.
  // cuando una clase simple funciona bien
}
```

## Evitar Over-Engineering

### ❌ NO Crear Abstracciones "Por Si Acaso"

**Incorrecto**:
```typescript
// ❌ MAL: Crear abstracciones que no se necesitan todavía
interface IRepository<T> {
  // Interface genérica que no se usa en ningún lado
}
```

**Correcto**:
```typescript
// ✅ BIEN: Crear interfaces cuando realmente se necesiten
interface UserRepository {
  // Interface específica que se usa
}
```

### ❌ NO Implementar Patrones Complejos Sin Necesidad

Si una solución simple funciona, no agregar:
- Multiple inheritance
- Decorators complejos
- Patrones de diseño avanzados sin justificación
- Frameworks adicionales innecesarios

### ✅ Implementar Solo lo Necesario

**Regla**: Si `proyect_requirements.md` no lo menciona explícitamente, probablemente no es necesario para el MVP.

### ✅ Refactorizar Cuando Realmente Se Necesite

- Primero, hacerlo funcionar (simple)
- Después, si realmente se necesita, refactorizar
- No optimizar prematuramente

## Verificación de Alcance

**ANTES** de agregar cualquier feature, consultar:

1. `proyect_requirements.md` - ¿Está en los requerimientos funcionales?
2. `proyect_requirements.md` sección "Alcance del MVP (Explícitamente Fuera)" - ¿Está excluida?
3. `technical_checklist.md` - ¿Es parte de la fase actual?

### Features Explícitamente Fuera del Alcance

Según `proyect_requirements.md`, NO implementar:
- ❌ Pagos
- ❌ Cancelación o reprogramación de citas
- ❌ Recordatorios automáticos previos
- ❌ Chats entre usuarios
- ❌ Panel administrativo
- ❌ Manejo avanzado de calendarios (feriados, excepciones, buffers)
- ❌ Multimoneda o internacionalización

## Señales de Over-Engineering

Si encuentras estos patrones, probablemente hay over-engineering:

1. **Abstracciones no usadas**: Interfaces o clases creadas "por si acaso"
2. **Patrones complejos sin justificación**: Usar design patterns avanzados sin necesidad real
3. **Múltiples capas innecesarias**: Agregar capas que no aportan valor
4. **Configuraciones complejas**: Setup excesivo para funcionalidad simple
5. **Features fuera del MVP**: Implementar cosas no requeridas

## Balance: KISS vs Clean Architecture

**KISS no significa código desorganizado**.

- ✅ Mantener Clean Architecture (simplicidad en la estructura)
- ✅ Mantener SOLID (simplicidad en el diseño)
- ❌ NO significa mezclar capas por "simplicidad"
- ❌ NO significa evitar patrones necesarios (como Strategy para notificaciones)

**Regla**: Usar la solución MÁS SIMPLE que respete Clean Architecture y SOLID.

## Ejemplos Prácticos

### Validación Simple

**✅ BIEN (KISS)**:
```typescript
// Validación simple y directa
if (!email || !email.includes('@')) {
  throw new Error('Invalid email');
}
```

**❌ MAL (Over-engineering)**:
```typescript
// Validación compleja innecesaria para MVP
class EmailValidatorFactory {
  createValidator(config) {
    return new CompositeValidator([
      new RegexValidator(),
      new DomainValidator(),
      new MXRecordValidator(),
      // ... para un MVP simple
    ]);
  }
}
```

### Persistencia Simple

**✅ BIEN (KISS)**:
```typescript
// Prisma directamente en el repositorio
export class PrismaUserRepository {
  async save(user: User): Promise<void> {
    await this.prisma.user.create({ data: user });
  }
}
```

**❌ MAL (Over-engineering)**:
```typescript
// Múltiples capas innecesarias
class UserRepositoryDecorator {
  constructor(private repository: IRepository<User>) {}
  // ... wrappers innecesarios
}
```

## Checklist KISS

Antes de implementar:
- ✅ ¿Es la solución más simple que funciona?
- ✅ ¿Está dentro del alcance del MVP?
- ✅ ¿No estoy agregando complejidad innecesaria?
- ✅ ¿Realmente necesito esta abstracción ahora?
- ✅ ¿Esto está en los requerimientos o es "nice to have"?
