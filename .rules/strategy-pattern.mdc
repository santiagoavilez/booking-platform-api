---
alwaysApply: false
---

# Strategy Pattern for Notifications

## Purpose

The notification system uses Strategy Pattern to allow multiple channels (Email, SMS, Push) without modifying existing code when new channels are added.

## Structure

### 1. Interface in Domain (Contract)

```typescript
// domain/services/notification-strategy.interface.ts
export interface NotificationStrategy {
  send(to: string, message: string): Promise<void>;
}
```

**Rule**: The interface must be in `domain/` to keep it independent of implementations.

### 2. Implementations in Infrastructure (Concrete Strategies)

```typescript
// infrastructure/notifications/email.strategy.ts
import { NotificationStrategy } from '../../domain/services/notification-strategy.interface';

export class EmailStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // Email-specific implementation
  }
}
```

```typescript
// infrastructure/notifications/sms.strategy.ts
import { NotificationStrategy } from '../../domain/services/notification-strategy.interface';

export class SMSStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // SMS-specific implementation
  }
}
```

```typescript
// infrastructure/notifications/push.strategy.ts
import { NotificationStrategy } from '../../domain/services/notification-strategy.interface';

export class PushStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // Push-specific implementation
  }
}
```

### 3. Factory to Select Strategy (Optional)

```typescript
// infrastructure/notifications/notification-strategy.factory.ts
import { NotificationStrategy } from '../../domain/services/notification-strategy.interface';
import { EmailStrategy } from './email.strategy';
import { SMSStrategy } from './sms.strategy';
import { PushStrategy } from './push.strategy';

export enum NotificationChannel {
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
}

export class NotificationStrategyFactory {
  static create(channel: NotificationChannel): NotificationStrategy {
    switch (channel) {
      case NotificationChannel.EMAIL:
        return new EmailStrategy();
      case NotificationChannel.SMS:
        return new SMSStrategy();
      case NotificationChannel.PUSH:
        return new PushStrategy();
      default:
        throw new Error(`Unknown notification channel: ${channel}`);
    }
  }
}
```

## Usage in Use Cases

```typescript
// application/use-cases/send-notifications.usecase.ts
import { NotificationStrategy } from '../../domain/services/notification-strategy.interface';
import { NotificationChannel } from '../../infrastructure/notifications/notification-strategy.factory';

export class SendNotificationsUseCase {
  async execute(
    recipient: string,
    message: string,
    channels: NotificationChannel[]
  ): Promise<void> {
    for (const channel of channels) {
      const strategy = NotificationStrategyFactory.create(channel);
      await strategy.send(recipient, message);
    }
  }
}
```

## Pattern Rules

### ✅ Open/Closed Principle

- **Open for extension**: Add new channel = new class
- **Closed for modification**: Do not modify existing code

**Extension example**:
```typescript
// infrastructure/notifications/telegram.strategy.ts (NEW)
export class TelegramStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // New implementation without modifying existing ones
  }
}
```

### ✅ All Strategies Implement the Same Contract

All must implement `NotificationStrategy` with the method `send(to: string, message: string)`.

**❌ BAD**:
```typescript
// ❌ Contract violation
export class EmailStrategy implements NotificationStrategy {
  async sendEmail(to: string, message: string): Promise<void> {
    // Method different from contract
  }
}
```

### ✅ Each Strategy is Independent

Each strategy must be independent and not depend on other strategies.

## File Location

### Domain (Interface)
- `src/domain/services/notification-strategy.interface.ts`

### Infrastructure (Implementations)
- `src/infrastructure/notifications/email.strategy.ts`
- `src/infrastructure/notifications/sms.strategy.ts`
- `src/infrastructure/notifications/push.strategy.ts`
- `src/infrastructure/notifications/notification-strategy.factory.ts`

## Adding New Channel

### Steps to Add "Telegram" Channel

1. **Create new strategy**:
```typescript
// infrastructure/notifications/telegram.strategy.ts
export class TelegramStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // Telegram implementation
  }
}
```

2. **Add to enum** (if using factory):
```typescript
// infrastructure/notifications/notification-strategy.factory.ts
export enum NotificationChannel {
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  TELEGRAM = 'telegram', // NEW
}
```

3. **Add to factory** (if using factory):
```typescript
static create(channel: NotificationChannel): NotificationStrategy {
  switch (channel) {
    // ... existing cases
    case NotificationChannel.TELEGRAM:
      return new TelegramStrategy(); // NEW
  }
}
```

4. **Done**: The rest of the code doesn't need changes.

## Pattern Advantages

1. **Extensibility**: Add channels without modifying existing code
2. **Testability**: Each strategy is tested independently
3. **Maintainability**: Changes in one channel don't affect others
4. **Separation of responsibilities**: Each strategy has a single responsibility

## Strategy Pattern Checklist

Before adding a new strategy:
- ✅ Does it completely implement `NotificationStrategy`?
- ✅ Is it in `infrastructure/notifications/`?
- ✅ Does it follow the same contract as other strategies?
- ✅ Does it not modify existing code?
- ✅ Can it be tested independently?
