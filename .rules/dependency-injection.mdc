---
alwaysApply: false
---

# Dependency Injection

## Principle

Dependency injection allows classes to depend on abstractions (interfaces) instead of concrete implementations, following the Dependency Inversion Principle (DIP).

## Configuration in NestJS

### Provider Location

**File**: `src/interfaces/providers.ts` or per module according to organization.

This file maps interfaces (tokens) with their concrete implementations.

### Provider Structure

```typescript
// interfaces/providers.ts
import { UserRepository } from '../../domain/repositories/user.repository';
import { DrizzleUserRepository } from '../../infrastructure/database/repositories/drizzle-user.repository';

export const USER_REPOSITORY = Symbol('UserRepository');

export const userProviders = [
  {
    provide: USER_REPOSITORY, // Token (can be string or Symbol)
    useClass: DrizzleUserRepository, // Concrete implementation
  },
];
```

## Injection Rules

### 1. Use Cases Depend on Interfaces

**✅ GOOD**:
```typescript
// application/use-cases/create-user.usecase.ts
import { UserRepository } from '../../domain/repositories/user.repository';

export class CreateUserUseCase {
  constructor(
    private readonly userRepository: UserRepository // Interface, not implementation
  ) {}
}
```

**❌ BAD**:
```typescript
// ❌ DO NOT depend directly on implementation
import { DrizzleUserRepository } from '../../infrastructure/database/repositories/drizzle-user.repository';

export class CreateUserUseCase {
  constructor(
    private readonly userRepository: DrizzleUserRepository // ❌ Concrete implementation
  ) {}
}
```

### 2. Providers Connect Interfaces with Implementations

```typescript
// interfaces/providers.ts
{
  provide: 'UserRepository', // or Symbol, or interface as token
  useClass: DrizzleUserRepository, // Implementation
}
```

### 3. NestJS Uses Providers to Resolve Dependencies

```typescript
// app.module.ts or feature module
import { userProviders } from './interfaces/providers';

@Module({
  providers: [
    CreateUserUseCase,
    ...userProviders, // Injects UserRepository → DrizzleUserRepository
  ],
})
export class AppModule {}
```

## Injection Tokens

### Option 1: String Token (Simple)

```typescript
// interfaces/providers.ts
export const userProviders = [
  {
    provide: 'UserRepository', // String token
    useClass: DrizzleUserRepository,
  },
];

// application/use-cases/create-user.usecase.ts
@Injectable()
export class CreateUserUseCase {
  constructor(
    @Inject('UserRepository') // Inject with string token
    private readonly userRepository: UserRepository
  ) {}
}
```

### Option 2: Symbol Token (Recommended)

```typescript
// interfaces/providers.ts
export const USER_REPOSITORY = Symbol('UserRepository');

export const userProviders = [
  {
    provide: USER_REPOSITORY, // Symbol token
    useClass: DrizzleUserRepository,
  },
];

// application/use-cases/create-user.usecase.ts
@Injectable()
export class CreateUserUseCase {
  constructor(
    @Inject(USER_REPOSITORY) // Inject with Symbol
    private readonly userRepository: UserRepository
  ) {}
}
```

### Option 3: Interface as Token (Advanced)

```typescript
// interfaces/providers.ts
export const userProviders = [
  {
    provide: UserRepository, // Interface as token (requires special configuration)
    useClass: DrizzleUserRepository,
  },
];
```

**Recommendation**: Use **Symbol tokens** for better organization and to avoid name collisions.

## Provider Organization

### By Domain Module

Organize providers by entity or domain module:

```typescript
// interfaces/providers/user.providers.ts
export const USER_REPOSITORY = Symbol('UserRepository');

export const userProviders = [
  {
    provide: USER_REPOSITORY,
    useClass: DrizzleUserRepository,
  },
];

// interfaces/providers/appointment.providers.ts
export const APPOINTMENT_REPOSITORY = Symbol('AppointmentRepository');

export const appointmentProviders = [
  {
    provide: APPOINTMENT_REPOSITORY,
    useClass: DrizzleAppointmentRepository,
  },
];
```

### Centralized File (Simple)

```typescript
// interfaces/providers.ts
export const USER_REPOSITORY = Symbol('UserRepository');
export const APPOINTMENT_REPOSITORY = Symbol('AppointmentRepository');

export const userProviders = [ /* ... */ ];
export const appointmentProviders = [ /* ... */ ];

export const allProviders = [
  ...userProviders,
  ...appointmentProviders,
];
```

## Complete Example

### 1. Define Interface in Domain

```typescript
// domain/repositories/user.repository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}
```

### 2. Implement in Infrastructure

```typescript
// infrastructure/database/repositories/drizzle-user.repository.ts
import { UserRepository } from '../../../domain/repositories/user.repository';

export class DrizzleUserRepository implements UserRepository {
  constructor(private readonly db: ReturnType<typeof drizzle>) {}

  async findById(id: string): Promise<User | null> {
    // Implementation with Drizzle
  }

  async save(user: User): Promise<void> {
    // Implementation with Drizzle
  }
}
```

### 3. Use in Use Case

```typescript
// application/use-cases/create-user.usecase.ts
import { UserRepository } from '../../domain/repositories/user.repository';
import { USER_REPOSITORY } from '../../interfaces/providers/user.providers';

@Injectable()
export class CreateUserUseCase {
  constructor(
    @Inject(USER_REPOSITORY)
    private readonly userRepository: UserRepository
  ) {}
}
```

### 4. Configure Provider

```typescript
// interfaces/providers/user.providers.ts
import { USER_REPOSITORY } from './tokens';
import { DrizzleUserRepository } from '../../infrastructure/database/repositories/drizzle-user.repository';

export const userProviders = [
  {
    provide: USER_REPOSITORY,
    useClass: DrizzleUserRepository,
  },
];
```

### 5. Register in Module

```typescript
// app.module.ts
import { userProviders } from './interfaces/providers/user.providers';
import { CreateUserUseCase } from './application/use-cases/create-user.usecase';

@Module({
  providers: [
    CreateUserUseCase,
    ...userProviders,
  ],
})
export class AppModule {}
```

## Multiple Implementation Injection

### For Strategy Pattern (Notifications)

```typescript
// interfaces/providers/notification.providers.ts
export const NOTIFICATION_STRATEGIES = Symbol('NotificationStrategies');

export const notificationProviders = [
  {
    provide: NOTIFICATION_STRATEGIES,
    useFactory: () => ({
      email: new EmailStrategy(),
      sms: new SMSStrategy(),
      push: new PushStrategy(),
    }),
  },
];
```

## Factories for Complex Dependencies

```typescript
// interfaces/providers.ts
export const userProviders = [
  {
    provide: USER_REPOSITORY,
    useFactory: (db: ReturnType<typeof drizzle>) => {
      return new DrizzleUserRepository(db);
    },
    inject: [DrizzleService], // Required dependencies
  },
];
```

## Important Rules

### ✅ DO

1. **Use interfaces in use cases**: Use cases must depend on interfaces, not implementations
2. **Configure providers centrally**: Keep DI configuration organized in `interfaces/providers.ts`
3. **Use Symbol tokens**: Prefer Symbols over strings to avoid collisions
4. **Organize by domain**: Group providers by domain module

### ❌ DON'T

1. **DO NOT inject implementations directly in use cases**: Always use interfaces
2. **DO NOT mix DI logic with business logic**: DI configuration goes in `interfaces/providers.ts`
3. **DO NOT use `any` in injection types**: Type dependencies correctly
4. **DO NOT create circular dependencies**: Avoid cycles in injection

## DI Checklist

Before commit:
- ✅ Do use cases depend on interfaces, not implementations?
- ✅ Are providers configured in `interfaces/providers.ts`?
- ✅ Are Symbol tokens being used (or consistent strings)?
- ✅ Are dependencies correctly injected in modules?
- ✅ No circular dependencies?
