---
alwaysApply: true
---
## Liskov Substitution Principle (LSP)

### Rule

Implementations must completely fulfill the contracts of their interfaces/base interfaces. Any implementation must be able to replace its interface without breaking expected behavior.

### Application in Project

- If `NotificationStrategy` defines `send(to: string, message: string)`, ALL implementations must respect it
- If `UserRepository` defines `findById(id: string)`, all implementations must fulfill the contract

### ❌ Incorrect Example

```typescript
// ❌ BAD: Contract violation
export class EmailStrategy implements NotificationStrategy {
  // Missing 'message' parameter, violates contract
  async send(to: string): Promise<void> { /* ... */ }
}
```

### ✅ Correct Example

```typescript
// ✅ GOOD: Completely fulfills contract
export class EmailStrategy implements NotificationStrategy {
  async send(to: string, message: string): Promise<void> {
    // Implementation that fulfills exactly with the interface
  }
}
```

---

## Interface Segregation Principle (ISP)

### Rule

Clients should not depend on interfaces they don't use. Create specific interfaces instead of general ones.

### Application in Project

- `UserRepository` has methods ONLY for User
- `AppointmentRepository` has methods ONLY for Appointment
- Avoid "God Object" interfaces with methods for everything

### ❌ Incorrect Example

```typescript
// ❌ BAD: "God Object" interface with too many methods
interface Repository {
  findUser(id: string): User;
  findAppointment(id: string): Appointment;
  findAvailability(id: string): Availability;
  saveUser(user: User): void;
  saveAppointment(appointment: Appointment): void;
  // ... 50 more methods
}
```

### ✅ Correct Example

```typescript
// ✅ GOOD: Specific interfaces
interface UserRepository {
  findById(id: string): Promise<User>;
  save(user: User): Promise<void>;
}

interface AppointmentRepository {
  findById(id: string): Promise<Appointment>;
  findByProfessionalId(id: string): Promise<Appointment[]>;
  save(appointment: Appointment): Promise<void>;
}
```

---

## Dependency Inversion Principle (DIP)

### Rule

Depend on abstractions (interfaces), not on concrete implementations. High-level modules should not depend on low-level modules; both should depend on abstractions.

### Application in Project

- Use cases depend on `UserRepository` (interface), NOT on `DrizzleUserRepository` (implementation)
- Dependency injection in `interfaces/providers.ts` connects interfaces with implementations

### ❌ Incorrect Example

```typescript
// ❌ BAD: Direct dependency on implementation
export class CreateUserUseCase {
  constructor(private db: ReturnType<typeof drizzle>) {} // Depends on Drizzle directly
}
```

### ✅ Correct Example

```typescript
// ✅ GOOD: Dependency on abstraction

// application/use-cases/create-user.usecase.ts
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {} // Depends on interface
}

// interfaces/providers.ts (dependency injection)
{
  provide: 'UserRepository', // Interface token
  useClass: DrizzleUserRepository, // Concrete implementation
}
```

### Correct Flow

1. **Domain** defines the `UserRepository` interface
2. **Application** uses `UserRepository` (doesn't know Drizzle)
3. **Infrastructure** implements `DrizzleUserRepository`
4. **Interfaces** configures injection connecting interface → implementation

---

## SOLID Validation Checklist

Before committing, verify:

- ✅ Does each class have a single responsibility?
- ✅ Can functionality be extended without modifying existing code?
- ✅ Do implementations completely fulfill their contracts?
- ✅ Are interfaces specific, not "God Objects"?
- ✅ Do we depend on interfaces, not concrete implementations?
